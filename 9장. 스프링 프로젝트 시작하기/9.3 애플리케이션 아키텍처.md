# 9.3 애플리케이션 아키텍처
> 아키텍처의 가장 단순한 정의는 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것이라고 할 수 있다. 아키텍처는 단순히 정적인 구조를 나타내는 것으로만 생각하기 쉽지만 실제로는 그 구조에서 일어나는 동적인 행위와 깊은 관계가 있다.

## 9.3.1 계층형 아키텍처
* 관심, 책임, 성격, 변하는 이유와 방식이 서로 다른 것들을 분리함으로써 분리된 각 요소의 응집도는 높여주고 서로의 결합도를 낮추는 **관심사의 분리** 또한 아키텍처에 적용할 수 있다. 

### 아키텍처와 SoC

* 애플리케이션을 구성하는 오브젝트들을 비슷한 성격과 책임을 가진 것 끼리 묶을 수 있다.

	* DAO :  데이터 액세스 로직 담당
	* 서비스 오브젝트 : 특정 기술과 환경에 종속되지 않으면서 도메인의 업무에 밀접하게 관련을 갖고 있는 POJO 
		* DAO를 이용해 정보의 저장과 검색 진행
	 * 프레젠테이션(웹을 처리하는 코드) : 서블릿 컨테이너로부터 받은 사용자의 요청 정보를 해석해 POJO 기반의 서비스 오브젝트에 전달, 그 결과를 받아 다시 웹 사용자 인터페이스에 표시 가능한 형태로 변환
	 
> 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해 두는 것을 아키텍처 차원에서는 **계층형 아키텍처**라고 부른다. 
> 또는 계층이라는 의미를 가진 영어 단어인 티어를 써서 **멀티 티어 아키텍처**라고도 한다. 
> 보통 웹 기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 해서 **3계층 애플리케이션**이라고도 한다. 

### 3계층 아키텍처와 수직 계층

* 3계층 아키텍처는 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할을 하는 데이터 액세스 계층, 비즈니스 로직을 담고 있는 서비스 계층, 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리하는 프레젠테이션 계층으로 구분한다

![image](https://user-images.githubusercontent.com/42940194/58759847-6ab8c680-856b-11e9-8b30-6bbb3b282423.png)

#### 데이터 액세스 계층
* DAO 계층, DAO 패턴을 보편적으로 사용
* DB외에도 ERP, 레거시 시스템, 메인 프레임 등에 접근하는 역할을 하므로 EIS(Enterprise Information System) 계층 이라고도 함

* 데이터 엑세스 계층은 추상화 수준에 따른 구분으로 세분화된 계층으로 구분될 수 있다. 이것을 수직적인 계층이라 부르기도 함

![image](https://user-images.githubusercontent.com/42940194/58759851-7a380f80-856b-11e9-834b-2413f92890c2.png)

* 위 그림과 같이 JdbcTemplate을 사용하는 데이터 액세스 계층의 특징은 JdbcTemplate이 추상화를 위한 계층으로 사용되어 로우 레벨의 기반 계층에 존재하는 JDBC와 드라이버, 스프링의 트랜잭션 추상화 서비스의 동기화 기능을 간접적으로 이용하게 만든다는 것이다.
* 새로운 추상 계층을 도입할 때에는 **하위 계층의 변화에 대응하는 책임**을 갖게 된다. 

#### 서비스 계층
* 이상적인 POJO로 작성됨
* 객체 지향적인 설계 기법이 적용된 코드를 통해 비즈니스 로직의 핵심을 잘 담아내고, 쉽게 테스트하고 유연하게 확장 가능
* DAO 계층을 호출하고 활용해서 만들어짐
* *특별한 경우가 아니라면 추상화 수직 계층 구조를 가질 필요가 없다.* 기술 API를 직접 다루지 않기에 기술에 일관된 방식으로 접근하거나 편하게 사용하는 추상화는 필요 없다.

![image](https://user-images.githubusercontent.com/42940194/58759856-8ae88580-856b-11e9-84de-af486c8b1d98.png)

* 원칙적으로는 서비스 계층 코드가 기반 서비스 계층의구현에 종속 되면 안된다. 서비스 계층의 코드는 추상화된 서비스 인터페이스를 통해서만 접근하도록 만들어서 특정 구현과 기술에 대한 종속성을 제거해야 한다.

* 이상적인 서비스 계층은 데이터 액세스 및 프레젠테이션 계층이 바뀌어도 유지될 수 있어야 한다.

#### 프레젠테이션 계층 
* 가장 복잡한 계층으로 다양한 기술과 프레임워크의 조합을 가진다.
* 엔터프라이즈 애플리케이션의 프레젠테이션 계층은 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿 바탕
* 모든 프레젠테이션 로직이 서버의 프레젠테이션 계층의 컴포넌트에서 처리
* 스프링은 웹 기반의 프레젠테이션 계층을 개발할 수 있는 전용 웹 프레임워크를 제공하고 다양한 서드파티 웹 기술을 지원

### 계층형 아키텍처 설계의 원칙

> 각 계층은 응집도가 높으면서 다른 계층과 낮은 결합도를 유지할 수 있어야 한다.

* 각 계층은 자신의 계층에만 충실해야 하고 자신과 관련된 기술이 아닌 다른 기술 API의 사용을 삼가해야 한다.
* 자신의 역할과 기술에만 충실한 계층을 만들면 각 계층 사이의 결합도는 자연히 낮아진다.

* 계층 간 설계 실수 예시1)
```java
public ResultSet findUsersByName(String name) throws SQLException;
```
	- 문제점 : 데이터 액세스 계층의 기술과 그 역할을 다른 계층에 노출한다는 점
		- 서비스 계층에서 ResultSet이라는 데이터 액세스 계층에서 만들어진 오브젝트를 직접 다뤄야 함
		- 서비스 계층에서 SQLException을 처리하는 코드를 추가해야함 

<수정 코드>
```java
public List<User> findUsersByName(String name) throws DataAccessException;
```
	* 특정 계층에 종속되지 않는 단순한 오브젝트의 형태로 전달
	* 런타임 예외 사용

* 게층 간 설계 실수 예시2)
	* 프레젠테이션 계층의 오브젝트를 그대로 서비스 계층으로 전달하는 것
	* 서블릿의 HttpServletRequest나 HttpServletResponse, HttpSessoin과 같은 타입을 서비스 계층 인터페이스 메소드의 파라미터 타입으로 사용하면 안되고 특정 계층에 종속되지 않는 오브젝트 형태로 변환해 줘야 한다.

> * 계층 사이의 낮은 결합도를 깨뜨리지 않도록 설계
> * 계층 사이의 호출은 인터페이스를 통해 이루어져야 한다.
> * DI는 계층을 구분해 주지 않기 때문에 빈 사이의 의존관계를 만들 때 주의해야 한다.

## 9.3.2 애플리케이션 정보 아키텍처
* 엔터프라이즈 시스템은 동시에 많은 작업이 빠르게 수행돼야 하는 시스템
* 엔터프라이즈 애플리케이션은 일반적으로 사용자의 요청을 처리하는 동안만 간단한 상태를 유지
* 애플리케이션의 주요 상태 정보는 DB나 백엔드 시스템에 분산해 저장

> 애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰 지 결정하는 일도 아키텍처를 결정할 때 매우 중요한 기준이 된다. 엔터프라이즈 애플리케이션에 존재하는 정보를 단순히 **데이터로 다루는 경우**와 **오브젝트로 다루는 경우**, 두 가지 기준으로 구분해볼 수 있다.

> * 데이터 중심 아키텍처 : 애플리케이션에 흘러다니는 정보를 단순히 값이나 값을 담기 위한 목적의 오브젝트 형태로 취급하는 구조. DB나 백엔드 시스템에서 가져온 정보를 값으로 다루고 그 값을 취급하는 코드를 만들어 로직을 구현하고 값을 그대로 프레젠테이션 계층의 뷰, 즉 사용자가 보는 화면과 연결해주는 것

### 데이터 중심 아키텍처 구분

#### DB/SQL 중심의 로직 구현 방식
* 데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 점
ex) 사용자 이름으로 사용자 정보 조회 작업 
	* 비즈니스 로직인 검색 조건은 SQL로 만들어짐
		* SQL의 결과를 그대로 웹 페이지의 정보에 1:1 매핑해서 넣어주기 때문에 SQL은 이미 화면에 어떤 식으로 출력될 지 알고 있다.
	* SQL의 결과는 단순한 오브젝트로 전달 되고 서비스 계층은 할 것이 없다. 프레젠테이션 계층의 JSP뷰는 DAO의 SQL에서 정확히 어떤 필드 값을 리턴할지, 어떤 포맷으로 전달할 지 알고 있다. 

* 하나의 특정 업무에 모든 계층의 코드가 종속되어 업무의 내용이 바뀌면 모든 계층의 코드가 함께 변경됨.
* 대부분의 코드가 대응되는 작업 단위에 1:1로 매핑되기 때문에 코드가 중복되기 쉽다.

![image](https://user-images.githubusercontent.com/42940194/58759865-ae133500-856b-11e9-83d0-e8116feac997.png)

* 자바 코드가 단순히 DB와 웹 화면을 연결해주는 인터페이스로 전락.
* 변화에 취약

> DB에는 부하를 가능한 주지 않는 간단한 작업만 하고 복잡한 로직은 오브젝트에 담아 애플리케이션 내에서 처리하도록 만드는 것이 낫다.

#### 거대한 서비스 계층 방식
* DB에 부하가 걸리지 않도록 저장 프로시저의 사용을 자제하고 복잡한 SQL을 피하면서, 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는 것
* 여전히 SQL의 결과를 그대로 담고 있는 단순한 오브젝트 또는 맵을 이용해 데이터를 주고받음
* DB/SQL 중심 구현 방식보다 구조가 단순해지고 객체 지향 개발의 장점을 살릴 기회가 많아짐

![image](https://user-images.githubusercontent.com/42940194/58759874-bf5c4180-856b-11e9-80c5-54e8724b77ff.png)

* 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉬워 계층간의 결합도가 여전히 큼
* 서비스 계층의 메소드는 업무 트랜잭션 단위로 만들어지기 때문에 비슷한 기능의 코드가 여러 메소드에서 중복돼서 나타나기 쉽다.

___
> 데이터 중심 아키텍처의 특징은 계층 사이의 결합도가 높은 편이고 응집도는 떨어진다는 점이다. 화면을 중심으로 하는 업무 트랜잭션 단위로 코드가 모이기 때문에 처음엔 개발하기 편하지만 중복이 많아지기 쉽고 장기적으로 코드를 관리하고 발전시키기 힘들다는 단점이 있다.

## 9.3.3 오브젝트 중심 아키텍처
* 도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송하는 데 사용한다는 것

* 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용하는데, 대개 도메인 모델은 DB의 엔티티 설계에도 반영되기 때문에 관계형 DB의 엔티티 구조와도 유사한 형태일 가능성이 높다. 

### 데이터와 오브젝트

* 카테고리 - 글 예시
	* 조건에 맞는 모든 카테고리와 글 정보를 가져와서 화면에 출력하는 기능
![image](https://user-images.githubusercontent.com/42940194/58759880-cd11c700-856b-11e9-9a0f-0d94fd29d69e.png)


1. 데이터 중심 아키텍처

	* DAO에서 JOIN을 이용해 2차원 구조의 정보를 만듬
	* DAO에서 JDBC로 SQL을 실행하고 받은 결과를 다음과 같이 담아 서비스 계층으로 전달
```java
while(rs.next()) {
	Map<String, Object> resMap = new HashMap<String, Object>();
	resMap.put("categoryid", rs.getString(1));
	resMap.put("name", rs.getString(2));
	...
	list.add(resMap);
}
```
	* 서비스 계층에 전달되는 것은 List<Map<String, Object>> 타입
	* SQL의 결과에 모든 계층의 코드가 의존
	
2. 오브젝트 방식

	* 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 오브젝트 안에 담김
	* 도메인 모델은 애플리케이션 전 계층에서 동일한 의미를 가짐

도메인 오브젝트
```java
public class Category {
	int categoryid;
	String name;
	Set<Board> boards;

 	...
}

public class Board {
	int boardid;
	String name;
	...
}
```

	* 레퍼런스 변수를 이용해 다른 오브젝트를 참조
	* DB에서 가져온 데이터를 도메인 오브젝트 구조에 맞게 변환할 필요가 있음

### 도메인 오베젝트 사용의 문제점

* 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 조금 손해를 감수할 수 있다. 
	* 비즈니스 로직에서 도메인 오브젝트의 모든 필드가 필요하지 않을 수 있기 때문
* 오브젝트 관계에서 문제점이 생길 수 있음

* 해결 방법
	* 지연된 로딩 기법 : 최소한의 오브젝트 정보만 읽어두고 관계하고 있는 오브젝트가 필요한 경우에만 다이내믹하게 DB에서 다시 읽어 옴
	* JPA, JDO, 하이버네이트, TopLinK와 같은 오브젝트/RDB 매핑 기술을 사용(이상적)

### 오브젝트 활용 방법에 따른 구분

#### 빈약한 도메인 오브젝트 방식
* 도메인 오브젝트에 정보만 담겨 있고, 정보를 활용하는 아무런 기능도 갖고 있지 않은 오브젝트
* 계층 사이의 독립성을 확보하기 위해 특정 계층에 종속되지 않으면서 애플리케이션 전반에서 사용될 수 있는 정보를 담은 오브젝트로 많이 사용됨
* 서비스 계층에 비즈니스 로직이 담김 -> 데이터 중심 아키텍처의 거대 서비스 계층 구조와 비슷

![image](https://user-images.githubusercontent.com/42940194/58759884-d7cc5c00-856b-11e9-9423-c8b111ffc6d2.png)


* 서비스 계층의 메소드에 대부분의 비즈니스 로직이 들어 있기 때문에 로직의 재사용성이 떨어지고 중복의 문제가 발생하기 쉬움

#### 풍성한 도메인 오브젝트 방식
* 영리한 도메인 오브젝트 방식은도메인 오브젝트나 그 관련 오브젝트가 가진 정보와 깊은관계가 있는 비즈니스 로직을 도메인 오브젝트에 넣어주고, 서비스 계층의 비즈니스 로직에서 재사용하는 것

자신의 정보를 활용하는 로직을 담은 도메인 오브젝트
```java
public class Category {
	...
	List<Product> products;
	
	public int calcTotalOfProductPrice() {	
		int sum = 0;
		for(Product prd : this.products()) {
			sum += prd.getPrice();
		}
		return sum;
	}
```

* 서비스 계층의 메소드에 따로 만드는 경우보다 응집도가 높다. 
* 여러 종류의 도메인 오브젝트의 기능을 조합해서 만든 복잡한 비즈니스 로직은 서비스 계층의 오브젝트에 두는 것이 적당하다.

> 도메인 오브젝트는 스프링 컨테이너가 관리하는 빈이 아니기 때문에 직접 데이터 액세스 계층이나 기반 계층 또는 다른 서비스 계층의 오브젝트에 접근할 수 없어서 서비스 계층이 필요하다.

![image](https://user-images.githubusercontent.com/42940194/58759891-e87cd200-856b-11e9-82fd-d0206f00a1b0.png)

* 풍성한 도메인 오브젝트 방식은 빈약한 도메인 오브젝트 방식보다 서비스 계층의 코드가 간결하여 비즈니스 로직 코드를 이해하기도 쉽다.

### 도메인 계층 방식
* 도메인 계층의 역할과 비중이 극대화 되어 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 방식
* 도메인 오브젝트들이 하나의 독립적인 계층을 이뤄 서비스 계층과 데이터 액세스 계층 사이에 존재하게 하는 것

* 특징
	* 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아닌 도메인 계층의 오브젝트 안에서 진행
	* 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있다는 것
		* 빈이 아니지만 DI를 통해 가능하게 함(AspectJ AOP 필요)

* 도메인 오브젝트를 독립적인 계층으로 만들 경우 고려할 사항은 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지 말지 결정하는 것이다.
	1. 모든 계층에서 도메인 오브젝트 사용
		- 손쉽고 편한 방법
		- 도메인 오브젝트는 중요한 도메인/비즈니스 로직을 담당하기 때문에 중요한 비즈니스 로직을 담은 메소드를 함부로 호출한다면 심각한 문제가 일어날 수 있다.
			- 철저한 개발 가이드라인 설정하자
	2. 도메인 오브젝트는 도메인 계층을 벗어나지 못하도록 하는 것
		* 도메인 계층 밖으로 전달될 때는 별도 준비된 정보 전달용 오브젝트인 DTO(Data Transfer Object)에 도메인 오브젝트의 내용을 복사해서 넘겨줌
		* DTO는 상태의 변화를 허용하지 않고 읽기 전용으로 만들어

도메인 계층 방식
![image](https://user-images.githubusercontent.com/42940194/58759903-00545600-856c-11e9-9ccc-c157d63109e5.png)

	* 매우 복잡하고 변경이 잦은 도메인을 가진 경우에 사용 권장

## 9.3.4 스프링 애플리케이션을 위한 아키텍처 설계
* 계층형 아키텍처 - 3계층 구조
* 정보 전송 아키텍처 - 도메인 오브젝트 방식
* 상태 관리와 빈 스코프 
* 서드 파티 프레임워크, 라이브러리 적용

**참고링크**
 [https://dhsim86.github.io/web/2018/01/20/toby_spring_09_start_spring_project-post.html](https://dhsim86.github.io/web/2018/01/20/toby_spring_09_start_spring_project-post.html) 

