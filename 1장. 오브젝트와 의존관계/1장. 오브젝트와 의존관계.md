# 1장. 오브젝트와 의존관계

## 1.1 DAO의 생성


### 1) User
사용자 정보를 저장하는 클래스

* 사용자 정보를 저장할 때는 **자바빈** 규약을 따르는 오브젝트를 이용하면 편리

> 자바빈(=빈) : 디폴트 생성자와, 프로퍼티 관례를 따라 만들어진 오브젝트 (원래는 비주얼 툴에서 조작 가능한 컴포넌트를 말함)

```java
public class User {
    String id;
    String name;
    String password;
    
    public String getId() {
        return id;
    }
    
    public void setId(String id) {
        this.id = id;
    }
    
    // ...
}
```

#### USERS 테이블 구성
User 오브젝트에 담긴 정보가 실제로 보관될 DB 테이블

|필드명|타입|설정|
|--|--|--|
|Id|VARCHAR(10)|Primary Key|
|Name|VARCHAR(20)|Not null|
|Password|VARCHAR(20)|Not null|

    create table users {
        id varchar(10) primary key,
        name varchar(20) not null,
        password varchar(10) not null
    }

### 2) UserDao
사용자 정보를 DB에 넣고 관리할 수 있는 DAO 클래스

* **DAO(Data Access Object)** : DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트
* 사용자 정보의 등록, 수정, 삭제, 조회 기능을 주로 구현
* 책의 예제에서는 등록, 조회하는 기능만 구현

#### JDBC를 이용하는 작업의 순서

    1. DB 연결을 위한 Connection을 가져온다.
    2. SQL을 담은 Statement를 만든다.
    3. 만들어진 Statement를 실행한다.
    4. (조회의 경우) SQL 쿼리 실행 결과를 ResultSet으로 받아 정보를 저장할 객체로 넘겨준다.
    5. 작업이 끝나면 작업 중에 생성된 Statement, ResultSet, Connection 등을 닫아준다.
    (공유 리소스를 시스템으로 반환)
    6. JDBC API가 만들어내는 예외를 잡아서 직접 처리하거나 throws를 선언해서 메소드 바깥으로 던지게 한다.
    
    
```java
public class UserDao {
    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection(
                "jdbc:mysql://localhost/springbook?serverTimezone=Asia/Seoul", "spring", "book");
        
        PreparedStatement ps = c.prepareStatement(
                "insert into users(id, name, password) values (?, ?, ?)");
        
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());
        
        ps.executeUpdate();
        
        ps.close();
        c.close();
    }
    
    public User get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection(
                "jdbc:mysql://localhost/springbook?serverTimezone=Asia/Seoul", "spring", "book");
                
        PreparedStatement ps = c.prepareStatement(
                "select * from users where id = ?");
        ps.setString(1, id);
        
        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));
        
        rs.close();
        ps.close();
        c.close();
        
        return user;
    }
}
```

### 3) main()으로 테스트
```java
public static void main(String[] args) throws ClassNotFoundException, SQLException {
    UserDao dao = new UserDao();
    
    User user = new User();
    user.setId("cutelee2");
    user.setName("이소영2");
    user.setPassword("cuteleepw");
    
    dao.add(user);
    
    System.out.println(user.getId() + "등록 성공");
    
    User user2 = dao.get(user.getId());
    System.out.println(user2.getName());
    System.out.println(user2.getPassword());
    
    System.out.println(user2.getId() + "조회 성공");
}
```

## 1.2 DAO의 분리

1.1에서 생성한 DAO는 우리가 원하는대로 동작하지만, 모든 **관심사(=기능)** 가 한 객체 내에서 관리되고 있어 수정이 어려움

### 1) 관심사의 분리
소프트웨어 개발에서 사용자의 비즈니스 프로세스, 그에 따른 요구사항이 **끊임없이 바뀌기 때문에** 애플리케이션도 계속된 수정, 기능 확장 등이 필요함
> 내가 개발을 뭐같이 해서가 아니라, 새로운 기능을 추가하거나 기존의 기능을 바꾸거나 등등 계속 변경사항이 생김 (..)

* 변화가 필요할 때, **최소한의 수정**으로 가능하게 하는 것
* **분리**와 **확장**을 고려한 설계
* 변화는 대체로 집중된 한 가지 관심에 대해 일어나지만, 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많음

#### 관심사의 분리(Separation of Concerns)
관심이 같은 것끼리는 하나의 객체 안으로, 관심이 다른 것은 가능한 한 따로 떨어져서 최대한 서로 영향을 주지 않도록 분리하는 것

### 2) 커넥션 만들기의 추출
#### UserDao의 관심사항
1. DB와 연결을 위한 커넥션을 가져오는 방법
2. DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 방법
3. 작업이 완료된 후, 사용한 리소스 오브젝트(Statement, Connection)를 닫아주는 것

DB 커넥션을 가져오는 코드가 다른 관심사와 섞여 한 메소드 안에 들어있고, 같은 코드가 여러 메소드에 중복되어 있다. 만약 DB 커넥션을 바꾸는 방식이 바뀐다면 수 많은 메소드에서 커넥션 부분을 일일히 찾아서 수정하는 번거로움을 겪어야 한다.

#### 중복 코드 메소드 추출
커넥션을 가져오는 중복된 코드 분리하기
* 메소드 추출(extract method) 기법
* **getConnection()** : 클래스 내의 다른 메소드로 만들어서 각 메소드(add, get)에서 호출하여 사용하는 방식
```java

```

#### 변경사항에 대한 검증: 리팩토링과 테스트
* **리팩토링(refactoring)** : 기능에 영향을 주지 않으면서 코드 구조를 개선하는 것
* 리팩토링 후에는 원래의 기능이 정상적으로 작동하는지 테스트가 필요함

### 3) DB 커넥션 만들기의 독립
UserDao의 내부 동작을 드러내지 않고, 여러 DB 커넥션을 적용할 수 있는 방법

#### 상속을 통한 확장
getConnection()을 추상메서드로 만들고, 상속받은 각 클래스에서 정의하는 방식
* 기능을 수행하는 원래의 메서드(add, get)에서 getConnection()의 세부 구현을 몰라도 호출 방법과 반환 결과를 알고 있기 때문에 사용 가능
* **템플릿 메소드 패턴** : 슈퍼클래스에 기본적인 로직의 흐름을 만들고 기능의 일부를 **추상 메소드**나 **오버라이딩 가능한 protected 메소드** 등으로 만든 후, 서브 클래스에서 이를 구현하여 사용하는 방식
* 슈퍼클래스는 DB 커넥션을 가져오는 방식에 구애받지 않고 자유롭게 코드를 작성할 수 있음

#### 상속을 통한 확장의 문제점
* 자바는 클래스의 다중상속을 허용하지 않음
* 상속관계는 여전히 두 가지 다른 관심사에 대해 긴밀한 결합을 허용
	* 서브클래스는 슈퍼클래스의 모든 기능 이용 가능
	* 슈퍼클래스가 수정될 경우 모든 서브클래스에 수정이 필요할 수 있음
	* 위 문제를 막기 위해 슈퍼클래스 변화를 금지시키는 등 제약이 필요할 수 있음
* 확장된 기능(DB 커넥션 생성코드)를 다른 DAO 클래스에 적용 불가능
	* 여러 DAO가 생성될 경우 DAO간 getConnection()의 구현코드가 중복될 가능성

## 1.3 DAO의 확장
### 1) 클래스의 분리
메소드나 서브클래스로 관심사를 분리하는 것이 아니라, 별도의 클래스로 분리
* **리스트 1-6** : UserDao의 코드가 SimpleConnectionMaker라는 특정 클래스에 종속되어 있음

### 2) 인터페이스의 도입
두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 연결고리를 만들어주는 것
* **추상화** : 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리하는 작업
* **인터페이스(interface)** : 자신을 구현한 클래스에 대한 구체적인 정보 없이 기능만 정의하는 것
* **문제점** : DConnection 클래스의 생성자를 호출해서 오브젝트를 생성하므로, 의존 관계가 생김
	* UserDao의 코드에서 필요할 때마다 UserDao의 생성자 메소드를 직접 수정해야 함

### 3) 관계설정 책임의 분리
* **문제 발생의 원인** : 어떤 ConnectionMaker 구현 클래스를 사용할지 결정하는 코드가 있음(new DConnectionMaker())
* **문제해결** : 클라이언트 오브젝트에서 어떤 ConnectionMaker의 구현 클래스를 사용할 지 결정하도록 수정
* **클라이언트 오브젝트** : 한 오브젝트가 다른 오브젝트의 기능을 사용할 때, 사용하는 쪽

UserDao의 클라이언트에서 UserDao를 사용하기 전에, 먼저 UserDao가 어떤 ConnectionMaker의 구현 클래스를 사용할지 결정하도록 함
=> UserDao 오브젝트와 ConnectionMaker 오브젝트 사이의 관계를 설정해주는 것

* 오브젝트 사이의 관계 : 런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 형성
	* 만들어진 오브젝트가 있어야 함
	* 직접 생성자를 호출해서 만들어도 되고, 외부에서 만들어준 것을 가져와도 됨
	* 오브젝트는 메소드 파라미터 등을 통해 외부에서 내부로 전달이 가능

> 다형성 : 코드에서 특정 클래스를 전혀 알지 못하더라도, 해당 클래스가 구현한 인터페이스를 사용했다면 클래스의 오브젝트를 인터페이스의 타입으로 받아서 사용 가능

### 4) 원칙과 패턴
객체지향 기술의 여러 가지 이론

#### 개방 폐쇄 원칙(OCP, Open-Closed Principle)
클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
* 기능 확장 : DB 연결 방법 등(인터페이스를 통해 제공되는 확장 포인트)
* 변경 폐쇄 : 핵심 기능(SQL문 작성)은 변화에 영향을 받지 않고 유지(인터페이스를 이용하는 클래스 메서드)
* 인터페이스를 사용한 확장 기능 정의 API는 대부분 개방 폐쇄 원칙을 따름

#### 높은 응집도와 낮은 결합도(high coherence and low coupling)
* **높은 응집도** : 하나의 모듈, 클래스가 하나의 책임/관심사에만 집중되어 있음
	* 변화가 일어날 때 해당 모듈에서 변하는 부분이 큼
* **낮은 결합도** : 하나의 변경이 발생할 때 다른 모듈, 객체로 변경에 대한 요구가 전파되지 않는 것
	* **느슨한 연결** : 관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 서로 독립적이고 알 필요가 없게 만들어줌
	* 변화에 대응하는 속도가 빨라지고 구성이 깔끔해지며 확장이 편리함
	* **결합도** : 하나의 오브젝트가 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도

#### 전략패턴(Strategy Pattern)
기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부에 분리시키고, 이를 구현한 구체적인 알고리즘을 필요에 따라 바꿔서 사용할 수 있게 하는 디자인패턴
* 알고리즘 : 독립적인 책임으로 분리가 가능한 기능
* 위 기능을 대체 가능한 전략이라고 보기 때문에 이름이 전략패턴

## 1.4 제어의 역전(IoC, Inversion of Control)
### 1) 오브젝트 팩토리

### 2) 오브젝트 팩토리의 활용

### 3) 제어권의 이전을 통한 제어관계 역전



## 1.5 스프링의 IoC
### 1) 오브젝트 팩토리를 이용한 스프링 IoC

### 2) 애플리케이션 컨텍스트의 동작방식

### 3) 스프링 IoC의 용어 정리


## 1.6 싱글톤 레지스트리와 오브젝트 스코프
### 1) 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

### 2) 싱글톤과 오브젝트의 상태

### 3) 스프링과 빈의 스코프


## 1.7 의존관계 주입(DI)
### 1) 제어의 역전과 의존관계 주입

### 2) 런타임 의존관계 설정

### 3) 의존관계 검색과 주입

### 4) 의존관계 주입의 응용

### 5) 메소드를 이용한 의존관계 주입


## 1.8 XML을 이용한 설정
### 1) XML 설정

### 2) XML을 이용하는 애플리케이션 컨텍스트

### 3) DataSource 인터페이스로 변환

### 4) 프로퍼티 값의 주입

## 1.9 정리

