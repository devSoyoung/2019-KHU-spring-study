# 3. 다이내믹 프록시와 팩토리 빈
## 3-1 프록시와 프록시 패턴, 데코레이터 패턴
### 확장성을 고려한 기능 분리
* 전형적인 전략 패턴 사용이 가능
* 트랜잭션을 적용한다는 사실이 코드에 남아있음

### 적용 사실 자체의 분리가 필요
* UserServiceTx 생성 후 UserServieImpl에 트랜잭션 관련 코드를 모두 제거
* 부가기능 분리 시 부가기능 외 나머지 모든 기능은 원래 핵심기능을 가진 클래스로 위임해주어야 함

### 부가기능의 사용
* 클라이언트가 핵심기능을 가진 클래스를 직접 사용하면 부가기능을 사용할 수 없음
* 클라이언트는 인터페이스를 통해서만 핵심 기능을 사용
* 부가기능은 같은 인터페이스를 구현하여 끼어들어야 함
* 클라이언트는 부가기능을 통해 핵심기능을 이용하게 됨

### 프록시 패턴
![proxy image](https://t1.daumcdn.net/cfile/tistory/9945263D5BE0F18A16)

타켓(UserServiceImpl)에 대한 접근방법을 제어하려는 목적을 가진 경우 사용

> 타깃의 기능을 확장하거나 추가하지 않음. 대신 클라이언트가 타깃에 접근하는 방식을 변경(p. 433)

* **프록시** : 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 대리자 (`UserServiceTx`)
* **타깃** : 최종적으로 요청을 위임받아 처리하는 실제 오브젝트 (`UserServiceImpl`)

#### 프록시의 사용 목적
* 클라이언트가 타깃에 접근하는 방법을 제어
* 타깃에 부가적인 기능을 부여

#### 프록시의 사용 예시
* **원격 오브젝트를 사용하는 경우(RMI, EJB)** : 원격 오브젝트에 대한 프록시를 만들어두고, 클라이언트는 마치 로컬에 존재하는 오브젝트를 쓰는 것처럼 프록시를 사용
* **타킷에 대한 접근권한을 제어** : 수정 가능한 오브젝트가 있는데, 특정 레이어로 넘어가서는 읽기전용으로만 동작하게 강제해야 하는 경우

### 데코레이터 패턴
타깃에 부가적인 기능을 런타임에 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴
* 프록시 패턴의 확장 느낌
* 프록시가 한 개로 제한되지 않고 여러 개 사용 가능

> 필요하다면 언제든지 트랜잭션 외에도 다른 기능을 부여하는 데코레이터를 만들어서 UserServiceTx와 UserServiceImpl 사이에 추가해줄 수 있음

```xml
<!-- Decorator -->
<beans>
    <bean id="userService" class="springbook.user.service.UserServiceTx">
        <property name="userService" ref="userServiceImpl" />
        <property name="transactionManager" ref="transactionManager" />
    </bean>
    
    <!-- target -->
    <bean id="userServiceImpl" class="springbook.user.service.UserServiceImpl">
        <property name="userDao" ref="userDao"/>
    </bean> 
</beans>
```

#### 프록시의 구성과 프록시 작성의 문제점
```java
public class UserServiceTx implements UserService {
    UserService userService; //타깃 오브젝트
    ...
    
    public void add(User user) {
        this.userService.add(user); //메소드 구현과 위임
    }
    
    public void upgradeLevels() { //메소드 구현
    	//부가기능 수행
        TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
        try {
            userService.upgradeLevels(); //위임
            this.transactionManager.commit(status);
        } catch (RuntimeException e) {
            this.transactionManager.rollback(status);
            throw e;
        }
    }
}
```
`UserServiceTx` 코드는 `UserService` 인터페이스를 구현하고 타깃으로 요청을 위임하는 트랜잭션 부가기능을 수행하는 코드로 구분됨

1. 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다. 일일이 코드를 만들어 주고 타깃 인터페이스의 메소드가 추가되거나 변경될 때마다 함께 수정해야 한다.
2. 부가기능 코드가 중복될 가능성이 많다.

## 3-2. 다이내믹 프록시
프록시를 만드는 것은 번거롭지만, 자바에는 java.lang.reflect 패키지 안에 프록시를 손쉽게 만들게 지원해주는 클래스들이 있음

* **리플랙션(java.lang.reflect)**: 자바의 코드 자체를 추상화해서 접근하도록 만든 것

![dynamic proxy](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F99B197505C4266501FACA3)

* **다이내믹 프록시** : 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트
    * 클라이언트는 다이내믹 프록시를 통해 타깃의 인터페이스를 사용
    * 부가기능은 따로 `InvocationHandler`를 구현한 오브젝트에 담음
    
> 리플렉션을 이용해 공통적인 부분을 뽑아내서 트랜잭션을 적용하고 실제 기능을 하는 메소드를 invoke 시킬 수 있다.

## 3-3. 다이내믹 프록시를 이용한 트랜잭션 부가기능
트랜잭션 부가기능도 앞의 예시처럼 다이나믹 프록시를 이용해보자.
```java
public class TransactionHandler implements InvocationHandler {

  @Autowired
  private PlatformTransactionManager transactionManager;

  private Object target;
  private String pattern;

  public void setTarget(Object target) {
    this.target = target;
  }

  public void setPattern(String pattern) {
    this.pattern = pattern;
  }

  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    if (method.getName().startsWith(pattern)) {
      return invokeInTransaction(method, args);
    } else {
      return method.invoke(target, args);
    }
  }

  private Object invokeInTransaction(Method method, Object[] args) throws Throwable {

    TransactionStatus status = this.transactionManager
        .getTransaction(new DefaultTransactionDefinition());

    try {
      Object ret = method.invoke(target, args);
      this.transactionManager.commit(status);
      return ret;
    } catch (InvocationTargetException e) {
      this.transactionManager.rollback(status);
      throw e.getTargetException();
    }
  }
}
```

### 다이내믹 프록시를 이용하여 트랜잭션 부가기능을 구현한 경우 장점
* 타킷을 저장할 변수(`UserServiceImpl`)를 Object로 선언
    * 트랜잭션 적용이 필요한 어떤 타킷 오브젝트에도 적용할 수 있음
* method 이름 검사를 통해 트랜잭션이 필요한 함수에만 적용이 가능함
* 트랜잭션 관련 코드가 중복되지 않고 해당 프록시를 이용하면 됨

### 다이내믹 프록시를 이용하여 트랜잭션 부가기능을 구현한 경우 단점
비슷한 설정을 오브젝트마다 추가해주어야 함

> 이 문제를 해결하기 위해 스프링의 ProxyFactoryBean을 쓰자

***
## 참고링크
* [토비의 스프링 | 6장. AOP3 - 프록시 팩토리빈과 포인트컷](https://haviyj.tistory.com/30)
* [6.3 다이내믹 프록시와 팩토리 빈](https://davidpark20.tistory.com/48?category=779431)
