# 3. 다이내믹 프록시와 팩토리 빈
## 3-1 프록시와 프록시 패턴, 데코레이터 패턴
### 확장성을 고려한 기능 분리
* 전형적인 전략 패턴 사용이 가능
* 트랜잭션을 적용한다는 사실이 코드에 남아있음

### 적용 사실 자체의 분리가 필요
* UserServiceTx 생성 후 UserServieImpl에 트랜잭션 관련 코드를 모두 제거
* 부가기능 분리 시 부가기능 외 나머지 모든 기능은 원래 핵심기능을 가진 클래스로 위임해주어야 함

### 부가기능의 사용
* 클라이언트가 핵심기능을 가진 클래스를 직접 사용하면 부가기능을 사용할 수 없음
* 클라이언트는 인터페이스를 통해서만 핵심 기능을 사용
* 부가기능은 같은 인터페이스를 구현하여 끼어들어야 함
* 클라이언트는 부가기능을 통해 핵심기능을 이용하게 됨

### 프록시 패턴
![proxy image](https://t1.daumcdn.net/cfile/tistory/9945263D5BE0F18A16)

타켓(UserServiceImpl)에 대한 접근방법을 제어하려는 목적을 가진 경우 사용

> 타깃의 기능을 확장하거나 추가하지 않음. 대신 클라이언트가 타깃에 접근하는 방식을 변경(p. 433)

* **프록시** : 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 대리자 (`UserServiceTx`)
* **타깃** : 최종적으로 요청을 위임받아 처리하는 실제 오브젝트 (`UserServiceImpl`)

#### 프록시의 사용 목적
* 클라이언트가 타깃에 접근하는 방법을 제어
* 타깃에 부가적인 기능을 부여

#### 프록시의 사용 예시
* **원격 오브젝트를 사용하는 경우(RMI, EJB)** : 원격 오브젝트에 대한 프록시를 만들어두고, 클라이언트는 마치 로컬에 존재하는 오브젝트를 쓰는 것처럼 프록시를 사용
* **타킷에 대한 접근권한을 제어** : 수정 가능한 오브젝트가 있는데, 특정 레이어로 넘어가서는 읽기전용으로만 동작하게 강제해야 하는 경우

### 데코레이터 패턴
타깃에 부가적인 기능을 런타임에 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴
* 프록시 패턴의 확장 느낌
* 프록시가 한 개로 제한되지 않고 여러 개 사용 가능

> 필요하다면 언제든지 트랜잭션 외에도 다른 기능을 부여하는 데코레이터를 만들어서 UserServiceTx와 UserServiceImpl 사이에 추가해줄 수 있음

```xml
<!-- Decorator -->
<beans>
    <bean id="userService" class="springbook.user.service.UserServiceTx">
        <property name="userService" ref="userServiceImpl" />
        <property name="transactionManager" ref="transactionManager" />
    </bean>
    
    <!-- target -->
    <bean id="userServiceImpl" class="springbook.user.service.UserServiceImpl">
        <property name="userDao" ref="userDao"/>
    </bean> 
</beans>
```

#### 프록시의 구성과 프록시 작성의 문제점
```java
public class UserServiceTx implements UserService {
    UserService userService; //타깃 오브젝트
    ...
    
    public void add(User user) {
        this.userService.add(user); //메소드 구현과 위임
    }
    
    public void upgradeLevels() { //메소드 구현
    	//부가기능 수행
        TransactionStatus status = this.transactionManager.getTransaction(new DefaultTransactionDefinition());
        try {
            userService.upgradeLevels(); //위임
            this.transactionManager.commit(status);
        } catch (RuntimeException e) {
            this.transactionManager.rollback(status);
            throw e;
        }
    }
}
```
`UserServiceTx` 코드는 `UserService` 인터페이스를 구현하고 타깃으로 요청을 위임하는 트랜잭션 부가기능을 수행하는 코드로 구분됨

1. 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다. 일일이 코드를 만들어 주고 타깃 인터페이스의 메소드가 추가되거나 변경될 때마다 함께 수정해야 한다.
2. 부가기능 코드가 중복될 가능성이 많다.

## 3-2. 다이내믹 프록시
프록시를 만드는 것은 번거롭지만, 자바에는 java.lang.reflect 패키지 안에 프록시를 손쉽게 만들게 지원해주는 클래스들이 있음

* **리플랙션(java.lang.reflect)**: 자바의 코드 자체를 추상화해서 접근하도록 만든 것

![dynamic proxy](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory&fname=http%3A%2F%2Fcfile6.uf.tistory.com%2Fimage%2F99B197505C4266501FACA3)

* **다이내믹 프록시** : 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트
    * 클라이언트는 다이내믹 프록시를 통해 타깃의 인터페이스를 사용
    * 부가기능은 따로 InvocationHandler를 구현한 오브젝트에 담음

## 3-3. 다이내믹 프록시를 이용한 트랜잭션 부가기능

## 3-4. 다이내믹 프록시를 위한 팩토리 빈

## 3-5. 프록시 팩토리 빈 방식의 장점과 한계
### 프록시 팩토리 빈의 재사용
* TransactionHandler를 이용하는 다이내믹 프록시를 생성해주는 TxProxyFactoryBean은 코드 수정 없이 다양한 클래스에 적용 가능
* 설정 변경을 통한 트랜잭션 기능 부가

프록시 팩토리 빈을 통해 프록시 기법을 빠르고 효과적으로 적용 가능

### 장점
데코레이터 패턴 적용의 문제점을 해결
* 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움 제거
* 부가 기능 코드의 중복 문제 해결

### 한계
프록시를 통해 부가기능을 제공하는 단위 : 메소드
* 하나의 클래스 안에 여러 개의 메소드 적용은 가능하지만, 한 번에 여러 개의 클래스에 공통적인 부가기능 제공이 불가
* 하나의 타깃에 여러 개의 부가 기능을 적용할 때 빈 설정이 부가기능의 개수만큼 붙어야 함
* TransactionHandler 오브젝트가 프록시 팩토리 빈 개수만큼 만들어짐

***
## 참고링크
* [토비의 스프링 | 6장. AOP3 - 프록시 팩토리빈과 포인트컷](https://haviyj.tistory.com/30)
* [6.3 다이내믹 프록시와 팩토리 빈](https://davidpark20.tistory.com/48?category=779431)
