# 2. 고립된 단위 테스트
단위테스트는 쉽고, 빠르고 명확한 작은 단위어야 한다.
* 테스트 실패 시 원인을 찾기 쉽기 때문
* **불가능한 경우** : 다른 오브젝트와 환경에 의존하고 있을 때, 테스트 중인 대상에서 생긴 오류인지 다른 오브젝트나 환경의 오류인지 원인을 찾기 쉽지 않음

## 2-1. 복잡한 의존관계 속의 테스트

![image](https://dhsim86.github.io/static/assets/img/blog/web/2017-09-07-toby_spring_06_aop/02.png)

### UserService
UserService는 매우 간단한 기능만을 가지고 있지만, 세 가지 타입의 의존 오브젝트가 필요하다.
* `UserDaoJdbc`: DB, 데이터를 주고받기 위한 클래스
* `TransactionManager`: 트랜잭션 처리
* `MailSender`: 메일 전송

### UserServiceTest
본래의 목적인 UserService에 대한 테스트임
* 세 가지 의존관계를 갖고 있기 때문에, 테스트 진행 동안 세 오브젝트가 모두 정상이어야 함
* 실제로는 해당 오브젝트 뒤에 존재하는 더 많은 오브젝트, 환경, 서비스, 서버 등을 함께 테스트하는 것

## 2-2. 테스트 대상 오브젝트 고립시키기
테스트 대상에 외부 환경에 영향받지 않으려면 테스트를 고립시키고, 대역을 사용해야 한다.

### 테스트를 위한 UserServiceImpl 고립
사전에 테스트를 위해 준비된 동작만 하도록 만든 두개의 목 오브젝트에만 의존하는, 완벽하게 고립된 테스트 대상으로 만들 수 있다. 

### 단위테스트 vs 통합테스트
#### 단위테스트
테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해, 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트 하는 것 (p. 425)

#### 통합테스트 
두개 이상의, 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트 하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트. (p. 425)

* 둘 중 항상 단위테스트를 먼저 고려할 것
* 외부 리소스를 사용하는 경우에는 통합테스트를 함
    * 외부와의 의존관계는 모두 차단하고, 필요에 따라 목 오브젝트 등의 테스트 대역을 사용
    
> 스프링이 지지하고 권장하는 깔끔하고 유연한 코드를 만들다보면 테스트도 그만큼 만들기 쉬워지고, 테스트는 다시 코드의 품질을 높여주고, 리팩토링과 개선에 대한 요기를 주기도 할 것이다. 반대로 좋은 코드를 만들려는 노력을 게을리하면 테스트 작성이 불편해지고, 테스트를 잘 만들지 않게 될 가능성이 높아진다. 테스트가 없으니 과감하게 리팩토링할 엄두를 내지 못할 것이고, 코드의 품질은 점점 떨어지고, 유연성과 확장성을 읽어갈지 모른다. (p. 427)

## 2-3. 목 프레임워크
단위 테스트를 만들기 위해서는 스텁이나 목 오브젝트의 사용이 필수적이다. 의존관계가 없는 단순한 클래스나 세부 로직을 검증하기 위해 메소드 단위로 테스트할 때가 아니라면, 대부분 의존 오브젝트를 필요로 하는 코드를 테스트하게 되기 때문이다.

목 오브젝트를 만드는 일은 번거로울 수 있다. 그러나 이런 번거로운 목 오브젝트를 편리하게 작성하도록 도와주는 다양한 목 오브젝트 지원 프레임워크가 있다.

### Mockito 프레임워크
목 클래스를 일일이 준비해둘 필요가 없도록 도와주는 프레임워크. 사용하기도 편리하고, 코드도 직관직이라 최근 많은 인기를 끌고 있다.

* 목 프레임워크의 특징은 목 클래스를 일일이 준비해둘 필요가 없다는 것
* 간단한 메소드 호출만으로 다이내믹하게 특정 인터페이스를 구현한 테스트용 목 오브젝트를 만들 수 있다.

1. 인터페이스를 이용해 목오브젝트 생성
2. 목 오브젝트가 리턴할 값이 있으면 이를 지정해 준다.
3. 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
4. 진짜 테스트

```java
UserDao mockUserDao = mock(UserDao.class);
```
USerDao 인터페이스를 구현한 테스트용 목 오브젝트는 다음과 같이 Mockito의 스태틱 메소드를 한 번 호출해주면 만들어진다.

```java
when(mockUserDao.getAll()).thenReturn(this.users);
```
이렇게 만들어진 목 오브젝트는 아직 아무런 기능이 없다. 여기에 먼저 getAll() 메소드가 불려올 때 사용자 목록을 리턴하도록 스텁 기능을 추가해줘야 한다. mockUserDao.getAll()이 호출됐을 때(when), users 리스트를 리턴해주라(thenReturn)는 선언이다.

> Mocktio를 통해 만들어진 목 오브젝트는 메소드의 호출과 관련된 모든 내용을 자동으로 저장해두고, 이를 간단한 메소드로 검증할 수 있게 해준다.

```java
verify(mockUserDao, times(2)).update(any(User.class));
```
테스트를 진행하는 동안 mockUserDao의 update() 메소드가 두 번 호출됐는지 확인하고 싶다면, 다음과 같이 검증 코드를 넣어주면 된다.

***
## 참고링크
* [토비의 스프링 6장(2) - 고립된 단위 테스트](https://happyer16.tistory.com/entry/토비의-스프링-6장2-고립된-단위-테스트?category=692836)
